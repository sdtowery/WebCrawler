"""
Data Structures
pandas dataframe - https://pandas.pydata.org/docs/user_guide/index.html

Data Visualization
Seaborn - https://seaborn.pydata.org/introduction.html

Classifiers
sci-kit learn KNN - https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html
sci-kit learn SVM - https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html
sci-kit learn MLP - https://scikit-learn.org/stable/modules/generated/sklearn.neural_network.MLPClassifier.html

Data Split
https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html

Metrics
https://scikit-learn.org/stable/modules/model_evaluation.html
https://en.wikipedia.org/wiki/Precision_and_recall
https://en.wikipedia.org/wiki/Receiver_operating_characteristic
"""

# Imports
import sys
from os.path import exists
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn import svm
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.neural_network import MLPClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix, accuracy_score, roc_auc_score


class HTML_Malware():

    def __init__(self, dataset_path):
        self.dataset_path = dataset_path
        self.dataset = None
        self.X_train = None
        self.X_test = None
        self.y_train = None
        self.y_test = None

        self.__load_dataset()

    # Reads the dataset file into a pandas dataframe
    def __load_dataset(self):
        self.dataset = pd.read_csv(self.dataset_path)
        print("DATASET READ")

    # Examines the dataset contents
    def inspect_dataset(self):

        # Show the dataset shape
        print("Dataset shape: %s" % (str(self.dataset.shape)))

        # Examine the first 5 rows from the dataset
        print("\nFirst 5 rows")
        print(self.dataset.head())

        # Get the descriptions of the dataset's data. This will determine what type of data preprocessing may be required
        print("\nDataset Info")
        print(self.dataset.info())

        # Print the distribution of the labels (-1 = benign 1 = malicious)
        print("\nLabel counts")
        print(self.dataset['label'].value_counts())

        # Visualize the distribution of the labels
        # sns.countplot(self.dataset['label'])

        # plt.show()

    # Dataset preprocessing
    def preprocess(self):
        # Dropping the webpage_id column - This would add noise into the classification
        self.dataset.drop('webpage_id', axis=1, inplace=True)

        # Seperate data and labels
        X = self.dataset.drop('label', axis=1)
        y = self.dataset['label']

        # Train and test splitting of data with an 80% training and 20% testing
        self.X_train, self.X_test, self.y_train, self.y_test = train_test_split(
            X, y, test_size=0.2)

    # KNN
    def knn(self):
        # Create the object for the model
        knc = KNeighborsClassifier()

        # Fit the model using X as training data and y as target values
        knc.fit(self.X_train, self.y_train)

        # Predict the class labels for the provided data
        pred_knc = knc.predict(self.X_test)

        # Return probability estimates for the test data
        prob_knc = knc.predict_proba(self.X_test)[:, 1]

        # Display the results
        # print("KNN")
        # print("Accuracy: %s" % (accuracy_score(self.y_test, pred_knc)))
        # print("AUC: %s" % (roc_auc_score(self.y_test, prob_knc)))
        # knnList = [accuracy_score(self.y_test, pred_knc),
        #            roc_auc_score(self.y_test, prob_knc)]
        knn_accuracy = accuracy_score(self.y_test, pred_knc)
        return knn_accuracy

    # SVM with RBF kernel
    def svm_rbf(self):
        # Create the object for the model
        rbf_svc = svm.SVC(gamma='scale', kernel='rbf', probability=True)

        # Fit the model using X as training data and y as target values
        rbf_svc.fit(self.X_train, self.y_train)

        # Predict the class labels for the provided data
        pred_rbf_svc = rbf_svc.predict(self.X_test)

        # Return probability estimates for the test data
        prob_rbf_svc = rbf_svc.predict_proba(self.X_test)[:, 1]

        # Display the results
        # print("SVM with RBF kernel")
        # print("Accuracy: %s" % (accuracy_score(self.y_test, pred_rbf_svc)))
        # print("AUC: %s" % (roc_auc_score(self.y_test, prob_rbf_svc)))
        svmRbfList = [accuracy_score(self.y_test, pred_rbf_svc), roc_auc_score(
            self.y_test, prob_rbf_svc)]
        return svmRbfList

    # SVM with linear kernel
    def svm_linear(self):
        # Create the object for the model
        linear_svc = svm.SVC(gamma='scale', kernel='linear', probability=True)

        # Fit the model using X as training data and y as target values
        linear_svc.fit(self.X_train, self.y_train)

        # Predict the class labels for the provided data
        pred_linear_svc = linear_svc.predict(self.X_test)

        # Return probability estimates for the test data
        prob_linear_svc = linear_svc.predict_proba(self.X_test)[:, 1]

        # Display the results
        # print("SVM with linear kernel")
        # print("Accuracy: %s" % (accuracy_score(self.y_test, pred_linear_svc)))
        # print("AUC: %s" % (roc_auc_score(self.y_test, prob_linear_svc)))
        svmList = [accuracy_score(self.y_test, pred_linear_svc), roc_auc_score(
            self.y_test, prob_linear_svc)]
        return svmList

    # MLP
    def mlp(self):
        # Create the object for the model
        mlp = MLPClassifier(max_iter=400)

        # Fit the model using X as training data and y as target values
        mlp.fit(self.X_train, self.y_train)

        # Predict the class labels for the provided data
        pred_mlp = mlp.predict(self.X_test)

        # Return probability estimates for the test data
        prob_mlp = mlp.predict_proba(self.X_test)[:, 1]

        # Display the results
        # print("MLP")
        # print("Accuracy: %s" % (accuracy_score(self.y_test, pred_mlp)))
        # print("AUC: %s" % (roc_auc_score(self.y_test, prob_mlp)))
        mlpList = [accuracy_score(self.y_test, pred_mlp),
                   roc_auc_score(self.y_test, prob_mlp)]
        return mlpList


# take in a csv file name
# file_name = sys.argv[1]
# if (exists(file_name)):
#     # Create the class object
#     html_obj = HTML_Malware(file_name)
# else:
#     html_obj = HTML_Malware('HTML_malware_dataset.csv')


# # Inspect the dataset
# html_obj.inspect_dataset()

# # Preprocess the dataset
# html_obj.preprocess()

# html_obj.knn()
# html_obj.svm_linear()
# html_obj.svm_rbf()
# html_obj.mlp()
